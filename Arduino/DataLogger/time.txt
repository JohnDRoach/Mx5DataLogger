/*
 * Race Car Logging
 * Functions:
 *   - Outputs inputs to LCD
 *   -- Speed
 *   -- xG
 *   -- yG
 *   -- zG
 *   -- Elapsed Time in 100th of seconds
 *   - Run Shift light
 */

#include <stdio.h>
#include <Fat16.h> // Needed because of the LogWriter app and you cannot chain dependencies =(
#include <LCD.h>
#include <MsTimer2.h>
#include <LogWriter.h>

// Pin Definitions
const int serialTxPin = 1;
const int speedSensorPin = 2;
const int lapModePin = 3;
const int startLoggingPin = 4;
const int shiftLightPin = 8;
const int videoOutStarterPin = 9;
const int xGPin = A0;
const int yGPin = A1;
const int zGPin = A2;

// Interrupts
const int speedSensorInterrupt = 0;
const int lapModeInterrupt = 1;

// Volatile Interrupt/Timer variables
volatile unsigned int rearSpeed = 0;
volatile unsigned int speedCounter = 0;
volatile unsigned int lap = 0;
volatile long lapTime = 0;
volatile long startOfLap = 0;

// Other Car parameter variables
float xG = 0.0;
float yG = 0.0;
float zG = 0.0;

// Other variables
boolean startedLogging = false;
SdCard sdCard;
LogWriter logFile;
boolean sdCardOk = false;

// Debouncing Logging switch variables (need to move into a class)
long startedDebouncingAt = 0;
const long debounceTime = 50;
int lastButtonState = LOW;
int buttonState = LOW;

void setup()
{
  attachInterrupt(speedSensorInterrupt, RearSpeedSensorInterrupt, RISING);
  attachInterrupt(lapModeInterrupt, LapModeInterrupt, RISING);
  pinMode(startLoggingPin, INPUT);
  pinMode(shiftLightPin, OUTPUT);
  pinMode(videoOutStarterPin, OUTPUT);
  LCD::Init();
  WriteInitialTextOnLcd();
  InitialiseSDCard();
  
  if(sdCardOk)
  {
    char* error = logFile.Init();
    if(error != 0)
    {
      LCD::WriteError(error);
    }
  }
  
  MsTimer2::set(500, TimerFired); // 500ms period
  MsTimer2::start();
}

void InitialiseSDCard()
{
  if (!sdCard.init())
  {
    LCD::WriteError("Card Init Error");
    sdCardOk = false;
    return;
  }

  if (!Fat16::init(&sdCard))
  {
    LCD::WriteError("Filesystem Init Err");
    sdCardOk = false;
    return;
  }
  
  sdCardOk = true;
  LCD::WriteError("SD Card Initialised");
}

void WriteInitialTextOnLcd(void)
{
  LCD::WriteTitleLine("---- Dashboard ----");
  LCD::WriteHeader(7, "Speed:");
  LCD::WriteHeader(6, "xG:");
  LCD::WriteHeader(5, "yG:");
  LCD::WriteHeader(4, "zG:");
  LCD::WriteHeader(3, "LapTime:");
  LCD::WriteHeader(2, "Lap:");
}

void loop(void)
{
  UpdateCarParameters();
  
  if(Logging())
  {
    StartLogging();
    LogToFile();
  }
  else
  {
    StopLogging();
    WriteToLCD();
  }
}

void UpdateCarParameters()
{
  // 0V = 0
  // 3.3V = 1023
  // 0G = 3.3/2 = 1023/2 ~ 512
  float tep = 0.0;
  tep = analogRead(xGPin);
  xG = (tep - 512)/102.3;
  tep = analogRead(yGPin);
  yG = (tep - 512)/102.3;
  tep = analogRead(zGPin);
  zG = (tep - 512)/102.3;
  
  if(lap == 1)
    lapTime = millis() - startOfLap;
  
  if(rearSpeed > 49 && rearSpeed < 60)
    digitalWrite(shiftLightPin, HIGH);
  else
    digitalWrite(shiftLightPin, LOW);
}

void LogToFile()
{
  // time, lapTime, lap, rearSpeed, xG, yG, zG
  long currentTime = millis();

  //Serial.println(currentTime);

  logFile.InnerFile()->print(currentTime);
  logFile.InnerFile()->print(',');
  logFile.InnerFile()->print(lapTime);
  logFile.InnerFile()->print(',');
  logFile.InnerFile()->print(lap);
  logFile.InnerFile()->print(',');
  logFile.InnerFile()->print(rearSpeed);
  logFile.InnerFile()->print(',');
  logFile.InnerFile()->print(xG);
  logFile.InnerFile()->print(',');
  logFile.InnerFile()->print(yG);
  logFile.InnerFile()->print(',');
  logFile.InnerFile()->print(zG);
  
  char* error = logFile.WriteLine("");
  if(error != 0)
  {
    LCD::WriteError(error);
  }
  
  delay(50);
}

void WriteToLCD(void)
{
  LCD::WriteVariable(7, rearSpeed);
  LCD::WriteVariable(6, xG);
  LCD::WriteVariable(5, yG);
  LCD::WriteVariable(4, zG);
  LCD::WriteVariable(3, lapTime);
  LCD::WriteVariable(2, lap);
}

boolean Logging()
{
  int pinState = digitalRead(startLoggingPin);
  long currentTime = millis();
  
  if(pinState != lastButtonState) {
    startedDebouncingAt = currentTime;
  }
  
  lastButtonState = pinState;
  
  if((currentTime - startedDebouncingAt) > debounceTime) {
    buttonState = pinState;
  }
  
  return buttonState == HIGH;
}

void TimerFired()
{
  //rearSpeed = speedCounter * 1.629; // this is per second
  rearSpeed = speedCounter * 3.257; // this is per 500ms
  speedCounter = 0;  
}

void RearSpeedSensorInterrupt()
{
  speedCounter++;
  StartLapCounting();
}

void StartLapCounting()
{
  if(lap < 1)
    startOfLap = millis();
  lap = 1;
}

void LapModeInterrupt()
{
  lap=2;
  
  if(!startedLogging)
    RefreshDisplay();
  else
    WriteToLCD();
}

void RefreshDisplay()
{
  LCD::ClearScreen();
  WriteInitialTextOnLcd();
}

void StartLogging()
{
  if(!startedLogging)
  {
    startedLogging = true;
    lap = 0;
    lapTime = 0;
    LCD::WriteTitleLine("----- Logging -----");
    AssertLoggingOutput();
    delay(360); // For data/video sync
  }
}

void StopLogging()
{
  if(startedLogging)
  {
    AssertLoggingOutput();
    char* error = logFile.CloseAndCreateNewFile();
    
    if(error != 0)
    {
      LCD::WriteError(error);
    }
    
    startedLogging = false;
    LCD::WriteTitleLine("---- Dashboard -----");
  }
}

void AssertLoggingOutput()
{
  digitalWrite(videoOutStarterPin, HIGH);
  delay(2);
  digitalWrite(videoOutStarterPin, LOW);
}

#ifndef JD_CalculatorTools_H
#define JD_CalculatorTools_H

private const unsigned short distancePerCount = 5000; // Need to actually work this out!!
private const unsigned char timerFrequencyInHertz = 50;  // This might end up 100Hz

// Returns distance travelled in metres for the count given
public static unsigned long DistanceTravelled(unsigned long count)
{
  return count * distancePerCount;
}


// Returns the speed in km/h
static unsigned char CalculateSpeed(unsigned long count)
{
  // speed = disatnce / time
  return DistanceTravelled(count) * timerFrequencyInHertz * 3600 / 1000;
}

#endif
